## Thread.sleep(0) 和 Thread.yield() 区别

### 想理解这个问题需要了解以下操作系统CPU竞争的策略

#### Unix系统使用的是时间片算

> 在时间片算法中，所有的进程排成一个队列。操作系统按照他们的顺序，给每个进程分配一段时间，即该进程允许运行的时间。如果在 时间片结束时进程还在运行，则CPU将被剥夺并分配给另一个进程。如果进程在时间片结束前阻塞或结束，则CPU当即进行切换。调度程 序所要做的就是维护一张就绪进程列表，，当进程用完它的时间片后，它被移到队列的末尾。

#### Windows则属于抢占式的

> 所谓抢占式操作系统，就是说如果一个进程得到了 CPU ，除非它自己放弃使用 CPU ，否则将完全霸占 CPU 。因此可以看出，在抢 占式操作系统中，操作系统假设所有的进程都是“人品很好”的，会主动退出 CPU 。
>
> cpu的控制权(下称 "优先级")=是由线程优先级优先级和饥饿程度(等待的时间越长饥饿程度越大)决定的.

Thread.sleep(n) 就是告诉操作系统在n秒内我不参与抢占cpu的控制权. 但是当n秒过了之后不一定cpu控制权就在自己手里,也就是说不一定就可以使用cpu执行代码.

#### Thread.sleep(0)

对于Thread.sleep(0) 而言就是从新发起一次cpu控制权的抢占.

在Unix类系统下而言当前线程主动放弃剩下时间片段的cpu控制权.到队尾重新排队等待获取cpu控制权.

在Windows类系统下而言当前线程主动放弃cpu控制权, 重新计算获取cpu控制权的优先级,与unix系统不同的是有可能下一个获得cpu控制权的线程仍然是当前线程.

##### Thread.sleep(0)使用的场景

在大循环里面经常会写一句Thread.Sleep(0)



> 另外，虽然上面提到说“除非它自己放弃使用 CPU ，否则将完全霸占 CPU”，但这个行为仍然是受到制约的——操作系统会监控你霸占CPU的情况，如果发现某个线程长时间霸占CPU，会强制使这个线程挂起，因此在实际上不会出现“一个线程一直霸占着 CPU 不放”的情况。至于我们的大循环造成程序假死，并不是因为这个线程一直在霸占着CPU。实际上在这段时间操作系统已经进行过多次CPU竞争了，只不过其他线程在获得CPU控制权之后很短时间内马上就退出了，于是就又轮到了这个线程继续执行循环，于是就又用了很久才被操作系统强制挂起。。。因此反应到界面上，看起来就好像这个线程一直在霸占着CPU一样。



sleep(0): 抛出 InterruptedException 

> java规范中并没有定义Thread.yield和Thread.sleep(0)的语义。jvm可以自由的去实现他们，可以不做任何操作，也可以给系统调度器提示。特别说下，sleep(0)在Unix系统下的语义是：把线程放到运行队列的末尾，并且让出执行权给其他同优先级的线程，很多的jvm也是这末实现的，但并不是要求必须这末实现，你想怎么玩就怎么玩，没人管你。
>
> 最后再来看下我们常用的hotspot中的具体实现：
>
> ![img](Thread.sleep(0) 和 Thread.yield() 区别.assets/20191212203414301.png)
>
> 上面这段代码是hotspot的源码，由于ConvertSleepToYield的默认值为true，所以在hotspot中当sleep(0)时效果相当于yield()。会让当前线程放弃剩余时间片，进入相同优先级线程队列的队尾，只有排在前面的所有同优先级线程完成调度后，它才能再次获执行的机会。
>
> 总结
> 结合java doc中这两个函数的注解总结下：
> Thread.yield()和Thread.sleep(0)语义实现取决于具体的jvm虚拟机，某些jvm可能什么都不做，而大多数虚拟机会让线程放弃剩余的cpu时间片，重新变为runnable状态，并放到同优先级线程队列的末尾等待cpu资源。 但是当我们调用Thread.yield()的那一刻，并不意味着当前线程立马释放cpu资源，这是因为获得时间片的线程从running切换到runable仍需要一定的准备时间，这段时间当前线程仍可能运行一小段时间。
> ————————————————
> 版权声明：本文为CSDN博主「斜阳雨陌」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。
> 原文链接：https://blog.csdn.net/qq_15037231/article/details/103440060
>
> 

